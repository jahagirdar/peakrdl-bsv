// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module some_register_map (
        input wire clk,
        input wire rst,
        input wire generic_reset,

        output logic s_axil_awready,
        input wire s_axil_awvalid,
        input wire [13:0] s_axil_awaddr,
        input wire [2:0] s_axil_awprot,
        output logic s_axil_wready,
        input wire s_axil_wvalid,
        input wire [31:0] s_axil_wdata,
        input wire [3:0]s_axil_wstrb,
        input wire s_axil_bready,
        output logic s_axil_bvalid,
        output logic [1:0] s_axil_bresp,
        output logic s_axil_arready,
        input wire s_axil_arvalid,
        input wire [13:0] s_axil_araddr,
        input wire [2:0] s_axil_arprot,
        input wire s_axil_rready,
        output logic s_axil_rvalid,
        output logic [31:0] s_axil_rdata,
        output logic [1:0] s_axil_rresp,

        input some_register_map_pkg::some_register_map__in_t hwif_in,
        output some_register_map_pkg::some_register_map__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [13:0] cpuif_addr;
    logic [31:0] cpuif_wr_data;
    logic [31:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [31:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    // Max Outstanding Transactions: 2
    logic [1:0] axil_n_in_flight;
    logic axil_prev_was_rd;
    logic axil_arvalid;
    logic [13:0] axil_araddr;
    logic axil_ar_accept;
    logic axil_awvalid;
    logic [13:0] axil_awaddr;
    logic axil_wvalid;
    logic [31:0] axil_wdata;
    logic [3:0] axil_wstrb;
    logic axil_aw_accept;
    logic axil_resp_acked;

    // Transaction request acceptance
    always_ff @(posedge clk) begin
        if(rst) begin
            axil_prev_was_rd <= '0;
            axil_arvalid <= '0;
            axil_araddr <= '0;
            axil_awvalid <= '0;
            axil_awaddr <= '0;
            axil_wvalid <= '0;
            axil_wdata <= '0;
            axil_wstrb <= '0;
            axil_n_in_flight <= '0;
        end else begin
            // AR* acceptance register
            if(axil_ar_accept) begin
                axil_prev_was_rd <= '1;
                axil_arvalid <= '0;
            end
            if(s_axil_arvalid && s_axil_arready) begin
                axil_arvalid <= '1;
                axil_araddr <= s_axil_araddr;
            end

            // AW* & W* acceptance registers
            if(axil_aw_accept) begin
                axil_prev_was_rd <= '0;
                axil_awvalid <= '0;
                axil_wvalid <= '0;
            end
            if(s_axil_awvalid && s_axil_awready) begin
                axil_awvalid <= '1;
                axil_awaddr <= s_axil_awaddr;
            end
            if(s_axil_wvalid && s_axil_wready) begin
                axil_wvalid <= '1;
                axil_wdata <= s_axil_wdata;
                axil_wstrb <= s_axil_wstrb;
            end

            // Keep track of in-flight transactions
            if((axil_ar_accept || axil_aw_accept) && !axil_resp_acked) begin
                axil_n_in_flight <= axil_n_in_flight + 1'b1;
            end else if(!(axil_ar_accept || axil_aw_accept) && axil_resp_acked) begin
                axil_n_in_flight <= axil_n_in_flight - 1'b1;
            end
        end
    end

    always_comb begin
        s_axil_arready = (!axil_arvalid || axil_ar_accept);
        s_axil_awready = (!axil_awvalid || axil_aw_accept);
        s_axil_wready = (!axil_wvalid || axil_aw_accept);
    end

    // Request dispatch
    always_comb begin
        cpuif_wr_data = axil_wdata;
        for(int i=0; i<4; i++) begin
            cpuif_wr_biten[i*8 +: 8] = {8{axil_wstrb[i]}};
        end
        cpuif_req = '0;
        cpuif_req_is_wr = '0;
        cpuif_addr = '0;
        axil_ar_accept = '0;
        axil_aw_accept = '0;

        if(axil_n_in_flight < 2'd2) begin
            // Can safely issue more transactions without overwhelming response buffer
            if(axil_arvalid && !axil_prev_was_rd) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axil_araddr[13:2], 2'b0};
                if(!cpuif_req_stall_rd) axil_ar_accept = '1;
            end else if(axil_awvalid && axil_wvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '1;
                cpuif_addr = {axil_awaddr[13:2], 2'b0};
                if(!cpuif_req_stall_wr) axil_aw_accept = '1;
            end else if(axil_arvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axil_araddr[13:2], 2'b0};
                if(!cpuif_req_stall_rd) axil_ar_accept = '1;
            end
        end
    end


    // AXI4-Lite Response Logic
    struct {
        logic is_wr;
        logic err;
        logic [31:0] rdata;
    } axil_resp_buffer[2];

    logic [1:0] axil_resp_wptr;
    logic [1:0] axil_resp_rptr;

    always_ff @(posedge clk) begin
        if(rst) begin
            for(int i=0; i<2; i++) begin
                axil_resp_buffer[i].is_wr <= '0;
                axil_resp_buffer[i].err <= '0;
                axil_resp_buffer[i].rdata <= '0;
            end
            axil_resp_wptr <= '0;
            axil_resp_rptr <= '0;
        end else begin
            // Store responses in buffer until AXI response channel accepts them
            if(cpuif_rd_ack || cpuif_wr_ack) begin
                if(cpuif_rd_ack) begin
                    axil_resp_buffer[axil_resp_wptr[0:0]].is_wr <= '0;
                    axil_resp_buffer[axil_resp_wptr[0:0]].err <= cpuif_rd_err;
                    axil_resp_buffer[axil_resp_wptr[0:0]].rdata <= cpuif_rd_data;

                end else if(cpuif_wr_ack) begin
                    axil_resp_buffer[axil_resp_wptr[0:0]].is_wr <= '1;
                    axil_resp_buffer[axil_resp_wptr[0:0]].err <= cpuif_wr_err;
                end
                axil_resp_wptr <= axil_resp_wptr + 1'b1;
            end

            // Advance read pointer when acknowledged
            if(axil_resp_acked) begin
                axil_resp_rptr <= axil_resp_rptr + 1'b1;
            end
        end
    end

    always_comb begin
        axil_resp_acked = '0;
        s_axil_bvalid = '0;
        s_axil_rvalid = '0;
        if(axil_resp_rptr != axil_resp_wptr) begin
            if(axil_resp_buffer[axil_resp_rptr[0:0]].is_wr) begin
                s_axil_bvalid = '1;
                if(s_axil_bready) axil_resp_acked = '1;
            end else begin
                s_axil_rvalid = '1;
                if(s_axil_rready) axil_resp_acked = '1;
            end
        end

        s_axil_rdata = axil_resp_buffer[axil_resp_rptr[0:0]].rdata;
        if(axil_resp_buffer[axil_resp_rptr[0:0]].err) begin
            s_axil_bresp = 2'b10;
            s_axil_rresp = 2'b10;
        end else begin
            s_axil_bresp = 2'b00;
            s_axil_rresp = 2'b00;
        end
    end

    logic cpuif_req_masked;
    logic external_req;
    logic external_pending;
    logic external_wr_ack;
    logic external_rd_ack;
    always_ff @(posedge clk) begin
        if(rst) begin
            external_pending <= '0;
        end else begin
            if(external_req & ~external_wr_ack & ~external_rd_ack) external_pending <= '1;
            else if(external_wr_ack | external_rd_ack) external_pending <= '0;
            assert(!external_wr_ack || (external_pending | external_req))
                else $error("An external wr_ack strobe was asserted when no external request was active");
            assert(!external_rd_ack || (external_pending | external_req))
                else $error("An external rd_ack strobe was asserted when no external request was active");
        end
    end

    // Read & write latencies are balanced. Stalls not required
    // except if external
    assign cpuif_req_stall_rd = external_pending;
    assign cpuif_req_stall_wr = external_pending;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic chip_id_reg;
        logic link_status;
        logic myRegInst;
        logic spi4_pkt_count;
        logic gige_pkt_count_reg;
        struct {
            logic head;
            logic tail;
            logic status;
        } fifo_port[8];
        logic empty_addrmap;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_strb_is_external;

    logic [13:0] decoded_addr;

    logic decoded_req;
    logic decoded_req_is_wr;
    logic [31:0] decoded_wr_data;
    logic [31:0] decoded_wr_biten;

    always_comb begin
        automatic logic is_external;
        is_external = '0;
        decoded_reg_strb.chip_id_reg = cpuif_req_masked & (cpuif_addr == 14'h0);
        is_external |= cpuif_req_masked & (cpuif_addr == 14'h0) & !cpuif_req_is_wr;
        decoded_reg_strb.link_status = cpuif_req_masked & (cpuif_addr == 14'h4);
        decoded_reg_strb.myRegInst = cpuif_req_masked & (cpuif_addr == 14'h10);
        decoded_reg_strb.spi4_pkt_count = cpuif_req_masked & (cpuif_addr == 14'h20);
        decoded_reg_strb.gige_pkt_count_reg = cpuif_req_masked & (cpuif_addr == 14'h24);
        for(int i0=0; i0<8; i0++) begin
            decoded_reg_strb.fifo_port[i0].head = cpuif_req_masked & (cpuif_addr == 14'h100 + i0*14'h10);
            decoded_reg_strb.fifo_port[i0].tail = cpuif_req_masked & (cpuif_addr == 14'h104 + i0*14'h10);
            decoded_reg_strb.fifo_port[i0].status = cpuif_req_masked & (cpuif_addr == 14'h108 + i0*14'h10);
        end
        decoded_reg_strb.empty_addrmap = cpuif_req_masked & (cpuif_addr >= 14'h2000) & (cpuif_addr <= 14'h2000 + 14'h3);
        is_external |= cpuif_req_masked & (cpuif_addr >= 14'h2000) & (cpuif_addr <= 14'h2000 + 14'h3);
        decoded_strb_is_external = is_external;
        external_req = is_external;
    end

    // Pass down signals to next stage
    assign decoded_addr = cpuif_addr;

    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic [3:0] next;
                logic load_next;
            } port0;
            struct {
                logic [3:0] next;
                logic load_next;
            } port1;
            struct {
                logic [3:0] next;
                logic load_next;
            } port2;
            struct {
                logic [3:0] next;
                logic load_next;
            } port3;
        } link_status;
        struct {
            struct {
                logic [1:0] next;
                logic load_next;
            } data0;
            struct {
                logic [1:0] next;
                logic load_next;
            } data1;
            struct {
                logic [1:0] next;
                logic load_next;
            } data2;
            struct {
                logic [1:0] next;
                logic load_next;
            } data3;
            struct {
                logic [1:0] next;
                logic load_next;
            } data4;
            struct {
                logic [1:0] next;
                logic load_next;
            } data5;
            struct {
                logic [1:0] next;
                logic load_next;
            } data6;
            struct {
                logic [1:0] next;
                logic load_next;
            } data7;
            struct {
                logic [1:0] next;
                logic load_next;
            } data8;
            struct {
                logic [1:0] next;
                logic load_next;
            } data9;
            struct {
                logic [1:0] next;
                logic load_next;
            } data10;
            struct {
                logic [1:0] next;
                logic load_next;
            } data11;
            struct {
                logic [1:0] next;
                logic load_next;
            } data12;
            struct {
                logic [1:0] next;
                logic load_next;
            } data13;
            struct {
                logic [1:0] next;
                logic load_next;
            } data14;
            struct {
                logic [1:0] next;
                logic load_next;
            } data15;
        } myRegInst;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } port1;
            struct {
                logic [15:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } port0;
        } spi4_pkt_count;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } port3;
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } port2;
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } port1;
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } port0;
        } gige_pkt_count_reg;
        struct {
            struct {
                struct {
                    logic [31:0] next;
                    logic load_next;
                } data;
            } head;
            struct {
                struct {
                    logic [31:0] next;
                    logic load_next;
                } data;
            } tail;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } full;
                struct {
                    logic next;
                    logic load_next;
                } empty;
                struct {
                    logic next;
                    logic load_next;
                } almost_empty;
                struct {
                    logic next;
                    logic load_next;
                } almost_full;
            } status;
        } fifo_port[8];
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic [3:0] value;
            } port0;
            struct {
                logic [3:0] value;
            } port1;
            struct {
                logic [3:0] value;
            } port2;
            struct {
                logic [3:0] value;
            } port3;
        } link_status;
        struct {
            struct {
                logic [1:0] value;
            } data0;
            struct {
                logic [1:0] value;
            } data1;
            struct {
                logic [1:0] value;
            } data2;
            struct {
                logic [1:0] value;
            } data3;
            struct {
                logic [1:0] value;
            } data4;
            struct {
                logic [1:0] value;
            } data5;
            struct {
                logic [1:0] value;
            } data6;
            struct {
                logic [1:0] value;
            } data7;
            struct {
                logic [1:0] value;
            } data8;
            struct {
                logic [1:0] value;
            } data9;
            struct {
                logic [1:0] value;
            } data10;
            struct {
                logic [1:0] value;
            } data11;
            struct {
                logic [1:0] value;
            } data12;
            struct {
                logic [1:0] value;
            } data13;
            struct {
                logic [1:0] value;
            } data14;
            struct {
                logic [1:0] value;
            } data15;
        } myRegInst;
        struct {
            struct {
                logic [15:0] value;
            } port1;
            struct {
                logic [15:0] value;
            } port0;
        } spi4_pkt_count;
        struct {
            struct {
                logic [7:0] value;
            } port3;
            struct {
                logic [7:0] value;
            } port2;
            struct {
                logic [7:0] value;
            } port1;
            struct {
                logic [7:0] value;
            } port0;
        } gige_pkt_count_reg;
        struct {
            struct {
                struct {
                    logic [31:0] value;
                } data;
            } head;
            struct {
                struct {
                    logic [31:0] value;
                } data;
            } tail;
            struct {
                struct {
                    logic value;
                } full;
                struct {
                    logic value;
                } empty;
                struct {
                    logic value;
                } almost_empty;
                struct {
                    logic value;
                } almost_full;
            } status;
        } fifo_port[8];
    } field_storage_t;
    field_storage_t field_storage;

    
    assign hwif_out.chip_id_reg.req = !decoded_req_is_wr ? decoded_reg_strb.chip_id_reg : '0;
    assign hwif_out.chip_id_reg.req_is_wr = decoded_req_is_wr;
    // Field: some_register_map.link_status.port0
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.link_status.port0.value;
        load_next_c = '0;
        
        // HW Write
        next_c = hwif_in.link_status.port0.next;
        load_next_c = '1;
        field_combo.link_status.port0.next = next_c;
        field_combo.link_status.port0.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.link_status.port0.load_next) begin
            field_storage.link_status.port0.value <= field_combo.link_status.port0.next;
        end
    end
    assign hwif_out.link_status.port0.value = field_storage.link_status.port0.value;
    // Field: some_register_map.link_status.port1
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.link_status.port1.value;
        load_next_c = '0;
        
        // HW Write
        next_c = hwif_in.link_status.port1.next;
        load_next_c = '1;
        field_combo.link_status.port1.next = next_c;
        field_combo.link_status.port1.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.link_status.port1.load_next) begin
            field_storage.link_status.port1.value <= field_combo.link_status.port1.next;
        end
    end
    assign hwif_out.link_status.port1.value = field_storage.link_status.port1.value;
    // Field: some_register_map.link_status.port2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.link_status.port2.value;
        load_next_c = '0;
        
        // HW Write
        next_c = hwif_in.link_status.port2.next;
        load_next_c = '1;
        field_combo.link_status.port2.next = next_c;
        field_combo.link_status.port2.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.link_status.port2.load_next) begin
            field_storage.link_status.port2.value <= field_combo.link_status.port2.next;
        end
    end
    assign hwif_out.link_status.port2.value = field_storage.link_status.port2.value;
    // Field: some_register_map.link_status.port3
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.link_status.port3.value;
        load_next_c = '0;
        
        // HW Write
        next_c = hwif_in.link_status.port3.next;
        load_next_c = '1;
        field_combo.link_status.port3.next = next_c;
        field_combo.link_status.port3.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.link_status.port3.load_next) begin
            field_storage.link_status.port3.value <= field_combo.link_status.port3.next;
        end
    end
    assign hwif_out.link_status.port3.value = field_storage.link_status.port3.value;
    // Field: some_register_map.myRegInst.data0
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data0.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data0.value & ~decoded_wr_biten[1:0]) | (decoded_wr_data[1:0] & decoded_wr_biten[1:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data0.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data0.next = next_c;
        field_combo.myRegInst.data0.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data0.value <= 2'h0;
        end else if(field_combo.myRegInst.data0.load_next) begin
            field_storage.myRegInst.data0.value <= field_combo.myRegInst.data0.next;
        end
    end
    assign hwif_out.myRegInst.data0.value = field_storage.myRegInst.data0.value;
    // Field: some_register_map.myRegInst.data1
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data1.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data1.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data1.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data1.next = next_c;
        field_combo.myRegInst.data1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data1.value <= 2'h1;
        end else if(field_combo.myRegInst.data1.load_next) begin
            field_storage.myRegInst.data1.value <= field_combo.myRegInst.data1.next;
        end
    end
    assign hwif_out.myRegInst.data1.value = field_storage.myRegInst.data1.value;
    // Field: some_register_map.myRegInst.data2
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data2.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data2.value & ~decoded_wr_biten[5:4]) | (decoded_wr_data[5:4] & decoded_wr_biten[5:4]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data2.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data2.next = next_c;
        field_combo.myRegInst.data2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data2.value <= 2'h2;
        end else if(field_combo.myRegInst.data2.load_next) begin
            field_storage.myRegInst.data2.value <= field_combo.myRegInst.data2.next;
        end
    end
    assign hwif_out.myRegInst.data2.value = field_storage.myRegInst.data2.value;
    // Field: some_register_map.myRegInst.data3
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data3.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data3.value & ~decoded_wr_biten[7:6]) | (decoded_wr_data[7:6] & decoded_wr_biten[7:6]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data3.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data3.next = next_c;
        field_combo.myRegInst.data3.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data3.value <= 2'h3;
        end else if(field_combo.myRegInst.data3.load_next) begin
            field_storage.myRegInst.data3.value <= field_combo.myRegInst.data3.next;
        end
    end
    assign hwif_out.myRegInst.data3.value = field_storage.myRegInst.data3.value;
    // Field: some_register_map.myRegInst.data4
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data4.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data4.value & ~decoded_wr_biten[9:8]) | (decoded_wr_data[9:8] & decoded_wr_biten[9:8]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data4.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data4.next = next_c;
        field_combo.myRegInst.data4.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data4.value <= 2'h0;
        end else if(field_combo.myRegInst.data4.load_next) begin
            field_storage.myRegInst.data4.value <= field_combo.myRegInst.data4.next;
        end
    end
    assign hwif_out.myRegInst.data4.value = field_storage.myRegInst.data4.value;
    // Field: some_register_map.myRegInst.data5
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data5.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data5.value & ~decoded_wr_biten[11:10]) | (decoded_wr_data[11:10] & decoded_wr_biten[11:10]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data5.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data5.next = next_c;
        field_combo.myRegInst.data5.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data5.value <= 2'h1;
        end else if(field_combo.myRegInst.data5.load_next) begin
            field_storage.myRegInst.data5.value <= field_combo.myRegInst.data5.next;
        end
    end
    assign hwif_out.myRegInst.data5.value = field_storage.myRegInst.data5.value;
    // Field: some_register_map.myRegInst.data6
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data6.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data6.value & ~decoded_wr_biten[13:12]) | (decoded_wr_data[13:12] & decoded_wr_biten[13:12]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data6.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data6.next = next_c;
        field_combo.myRegInst.data6.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data6.value <= 2'h2;
        end else if(field_combo.myRegInst.data6.load_next) begin
            field_storage.myRegInst.data6.value <= field_combo.myRegInst.data6.next;
        end
    end
    assign hwif_out.myRegInst.data6.value = field_storage.myRegInst.data6.value;
    // Field: some_register_map.myRegInst.data7
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data7.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data7.value & ~decoded_wr_biten[15:14]) | (decoded_wr_data[15:14] & decoded_wr_biten[15:14]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data7.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data7.next = next_c;
        field_combo.myRegInst.data7.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data7.value <= 2'h3;
        end else if(field_combo.myRegInst.data7.load_next) begin
            field_storage.myRegInst.data7.value <= field_combo.myRegInst.data7.next;
        end
    end
    assign hwif_out.myRegInst.data7.value = field_storage.myRegInst.data7.value;
    // Field: some_register_map.myRegInst.data8
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data8.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data8.value & ~decoded_wr_biten[17:16]) | (decoded_wr_data[17:16] & decoded_wr_biten[17:16]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data8.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data8.next = next_c;
        field_combo.myRegInst.data8.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data8.value <= 2'h0;
        end else if(field_combo.myRegInst.data8.load_next) begin
            field_storage.myRegInst.data8.value <= field_combo.myRegInst.data8.next;
        end
    end
    assign hwif_out.myRegInst.data8.value = field_storage.myRegInst.data8.value;
    // Field: some_register_map.myRegInst.data9
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data9.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data9.value & ~decoded_wr_biten[19:18]) | (decoded_wr_data[19:18] & decoded_wr_biten[19:18]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data9.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data9.next = next_c;
        field_combo.myRegInst.data9.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data9.value <= 2'h1;
        end else if(field_combo.myRegInst.data9.load_next) begin
            field_storage.myRegInst.data9.value <= field_combo.myRegInst.data9.next;
        end
    end
    assign hwif_out.myRegInst.data9.value = field_storage.myRegInst.data9.value;
    // Field: some_register_map.myRegInst.data10
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data10.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data10.value & ~decoded_wr_biten[21:20]) | (decoded_wr_data[21:20] & decoded_wr_biten[21:20]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data10.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data10.next = next_c;
        field_combo.myRegInst.data10.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data10.value <= 2'h2;
        end else if(field_combo.myRegInst.data10.load_next) begin
            field_storage.myRegInst.data10.value <= field_combo.myRegInst.data10.next;
        end
    end
    assign hwif_out.myRegInst.data10.value = field_storage.myRegInst.data10.value;
    // Field: some_register_map.myRegInst.data11
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data11.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data11.value & ~decoded_wr_biten[23:22]) | (decoded_wr_data[23:22] & decoded_wr_biten[23:22]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data11.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data11.next = next_c;
        field_combo.myRegInst.data11.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data11.value <= 2'h3;
        end else if(field_combo.myRegInst.data11.load_next) begin
            field_storage.myRegInst.data11.value <= field_combo.myRegInst.data11.next;
        end
    end
    assign hwif_out.myRegInst.data11.value = field_storage.myRegInst.data11.value;
    // Field: some_register_map.myRegInst.data12
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data12.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data12.value & ~decoded_wr_biten[25:24]) | (decoded_wr_data[25:24] & decoded_wr_biten[25:24]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data12.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data12.next = next_c;
        field_combo.myRegInst.data12.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data12.value <= 2'h0;
        end else if(field_combo.myRegInst.data12.load_next) begin
            field_storage.myRegInst.data12.value <= field_combo.myRegInst.data12.next;
        end
    end
    assign hwif_out.myRegInst.data12.value = field_storage.myRegInst.data12.value;
    // Field: some_register_map.myRegInst.data13
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data13.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data13.value & ~decoded_wr_biten[27:26]) | (decoded_wr_data[27:26] & decoded_wr_biten[27:26]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data13.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data13.next = next_c;
        field_combo.myRegInst.data13.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data13.value <= 2'h1;
        end else if(field_combo.myRegInst.data13.load_next) begin
            field_storage.myRegInst.data13.value <= field_combo.myRegInst.data13.next;
        end
    end
    assign hwif_out.myRegInst.data13.value = field_storage.myRegInst.data13.value;
    // Field: some_register_map.myRegInst.data14
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data14.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data14.value & ~decoded_wr_biten[29:28]) | (decoded_wr_data[29:28] & decoded_wr_biten[29:28]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data14.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data14.next = next_c;
        field_combo.myRegInst.data14.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data14.value <= 2'h2;
        end else if(field_combo.myRegInst.data14.load_next) begin
            field_storage.myRegInst.data14.value <= field_combo.myRegInst.data14.next;
        end
    end
    assign hwif_out.myRegInst.data14.value = field_storage.myRegInst.data14.value;
    // Field: some_register_map.myRegInst.data15
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.myRegInst.data15.value;
        load_next_c = '0;
        if(decoded_reg_strb.myRegInst && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.myRegInst && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.myRegInst.data15.value & ~decoded_wr_biten[31:30]) | (decoded_wr_data[31:30] & decoded_wr_biten[31:30]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.myRegInst.data15.next;
            load_next_c = '1;
        end
        field_combo.myRegInst.data15.next = next_c;
        field_combo.myRegInst.data15.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.myRegInst.data15.value <= 2'h3;
        end else if(field_combo.myRegInst.data15.load_next) begin
            field_storage.myRegInst.data15.value <= field_combo.myRegInst.data15.next;
        end
    end
    assign hwif_out.myRegInst.data15.value = field_storage.myRegInst.data15.value;
    // Field: some_register_map.spi4_pkt_count.port1
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.spi4_pkt_count.port1.value;
        load_next_c = '0;
        if(decoded_reg_strb.spi4_pkt_count && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.spi4_pkt_count && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.spi4_pkt_count.port1.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        if(hwif_in.spi4_pkt_count.port1.incr) begin // increment
            field_combo.spi4_pkt_count.port1.overflow = (((17)'(next_c) + 16'h1) > 16'hffff);
            next_c = next_c + 16'h1;
            load_next_c = '1;
        end else begin
            field_combo.spi4_pkt_count.port1.overflow = '0;
        end
        field_combo.spi4_pkt_count.port1.incrthreshold = (field_storage.spi4_pkt_count.port1.value >= 16'hcfff);
        field_combo.spi4_pkt_count.port1.next = next_c;
        field_combo.spi4_pkt_count.port1.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.spi4_pkt_count.port1.load_next) begin
            field_storage.spi4_pkt_count.port1.value <= field_combo.spi4_pkt_count.port1.next;
        end
    end
    assign hwif_out.spi4_pkt_count.port1.value = field_storage.spi4_pkt_count.port1.value;
    assign hwif_out.spi4_pkt_count.port1.incrthreshold = field_combo.spi4_pkt_count.port1.incrthreshold;
    // Field: some_register_map.spi4_pkt_count.port0
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.spi4_pkt_count.port0.value;
        load_next_c = '0;
        if(decoded_reg_strb.spi4_pkt_count && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.spi4_pkt_count && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.spi4_pkt_count.port0.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        if(hwif_in.spi4_pkt_count.port0.incr) begin // increment
            field_combo.spi4_pkt_count.port0.overflow = (((17)'(next_c) + 16'h1) > 16'hffff);
            next_c = next_c + 16'h1;
            load_next_c = '1;
        end else begin
            field_combo.spi4_pkt_count.port0.overflow = '0;
        end
        field_combo.spi4_pkt_count.port0.incrthreshold = (field_storage.spi4_pkt_count.port0.value >= 16'hcfff);
        field_combo.spi4_pkt_count.port0.next = next_c;
        field_combo.spi4_pkt_count.port0.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.spi4_pkt_count.port0.load_next) begin
            field_storage.spi4_pkt_count.port0.value <= field_combo.spi4_pkt_count.port0.next;
        end
    end
    assign hwif_out.spi4_pkt_count.port0.value = field_storage.spi4_pkt_count.port0.value;
    assign hwif_out.spi4_pkt_count.port0.incrthreshold = field_combo.spi4_pkt_count.port0.incrthreshold;
    // Field: some_register_map.gige_pkt_count_reg.port3
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.gige_pkt_count_reg.port3.value;
        load_next_c = '0;
        if(decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.gige_pkt_count_reg && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.gige_pkt_count_reg.port3.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        if(hwif_in.gige_pkt_count_reg.port3.incr) begin // increment
            field_combo.gige_pkt_count_reg.port3.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.gige_pkt_count_reg.port3.overflow = '0;
        end
        field_combo.gige_pkt_count_reg.port3.incrthreshold = (field_storage.gige_pkt_count_reg.port3.value >= 8'hff);
        field_combo.gige_pkt_count_reg.port3.next = next_c;
        field_combo.gige_pkt_count_reg.port3.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.gige_pkt_count_reg.port3.load_next) begin
            field_storage.gige_pkt_count_reg.port3.value <= field_combo.gige_pkt_count_reg.port3.next;
        end
    end
    assign hwif_out.gige_pkt_count_reg.port3.value = field_storage.gige_pkt_count_reg.port3.value;
    // Field: some_register_map.gige_pkt_count_reg.port2
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.gige_pkt_count_reg.port2.value;
        load_next_c = '0;
        if(decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.gige_pkt_count_reg && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.gige_pkt_count_reg.port2.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        if(hwif_in.gige_pkt_count_reg.port2.incr) begin // increment
            field_combo.gige_pkt_count_reg.port2.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.gige_pkt_count_reg.port2.overflow = '0;
        end
        field_combo.gige_pkt_count_reg.port2.incrthreshold = (field_storage.gige_pkt_count_reg.port2.value >= 8'hff);
        field_combo.gige_pkt_count_reg.port2.next = next_c;
        field_combo.gige_pkt_count_reg.port2.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.gige_pkt_count_reg.port2.load_next) begin
            field_storage.gige_pkt_count_reg.port2.value <= field_combo.gige_pkt_count_reg.port2.next;
        end
    end
    assign hwif_out.gige_pkt_count_reg.port2.value = field_storage.gige_pkt_count_reg.port2.value;
    // Field: some_register_map.gige_pkt_count_reg.port1
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.gige_pkt_count_reg.port1.value;
        load_next_c = '0;
        if(decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.gige_pkt_count_reg && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.gige_pkt_count_reg.port1.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        if(hwif_in.gige_pkt_count_reg.port1.incr) begin // increment
            field_combo.gige_pkt_count_reg.port1.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.gige_pkt_count_reg.port1.overflow = '0;
        end
        field_combo.gige_pkt_count_reg.port1.incrthreshold = (field_storage.gige_pkt_count_reg.port1.value >= 8'hff);
        field_combo.gige_pkt_count_reg.port1.next = next_c;
        field_combo.gige_pkt_count_reg.port1.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.gige_pkt_count_reg.port1.load_next) begin
            field_storage.gige_pkt_count_reg.port1.value <= field_combo.gige_pkt_count_reg.port1.next;
        end
    end
    assign hwif_out.gige_pkt_count_reg.port1.value = field_storage.gige_pkt_count_reg.port1.value;
    // Field: some_register_map.gige_pkt_count_reg.port0
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.gige_pkt_count_reg.port0.value;
        load_next_c = '0;
        if(decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end else if(decoded_reg_strb.gige_pkt_count_reg && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.gige_pkt_count_reg.port0.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        if(hwif_in.gige_pkt_count_reg.port0.incr) begin // increment
            field_combo.gige_pkt_count_reg.port0.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.gige_pkt_count_reg.port0.overflow = '0;
        end
        field_combo.gige_pkt_count_reg.port0.incrthreshold = (field_storage.gige_pkt_count_reg.port0.value >= 8'hff);
        field_combo.gige_pkt_count_reg.port0.next = next_c;
        field_combo.gige_pkt_count_reg.port0.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.gige_pkt_count_reg.port0.load_next) begin
            field_storage.gige_pkt_count_reg.port0.value <= field_combo.gige_pkt_count_reg.port0.next;
        end
    end
    assign hwif_out.gige_pkt_count_reg.port0.value = field_storage.gige_pkt_count_reg.port0.value;
    for(genvar i0=0; i0<8; i0++) begin
        // Field: some_register_map.fifo_port[].head.data
        always_comb begin
            automatic logic [31:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.fifo_port[i0].head.data.value;
            load_next_c = '0;
            if(decoded_reg_strb.fifo_port[i0].head && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.fifo_port[i0].head.data.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
                load_next_c = '1;
            end else if(hwif_in.fifo_port[i0].head.data.we) begin // HW Write - we
                next_c = hwif_in.fifo_port[i0].head.data.next;
                load_next_c = '1;
            end
            field_combo.fifo_port[i0].head.data.next = next_c;
            field_combo.fifo_port[i0].head.data.load_next = load_next_c;
        end

        always_ff @(posedge clk) begin
            if(field_combo.fifo_port[i0].head.data.load_next) begin
                field_storage.fifo_port[i0].head.data.value <= field_combo.fifo_port[i0].head.data.next;
            end
        end
        assign hwif_out.fifo_port[i0].head.data.value = field_storage.fifo_port[i0].head.data.value;
        // Field: some_register_map.fifo_port[].tail.data
        always_comb begin
            automatic logic [31:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.fifo_port[i0].tail.data.value;
            load_next_c = '0;
            if(decoded_reg_strb.fifo_port[i0].tail && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.fifo_port[i0].tail.data.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
                load_next_c = '1;
            end else if(hwif_in.fifo_port[i0].tail.data.we) begin // HW Write - we
                next_c = hwif_in.fifo_port[i0].tail.data.next;
                load_next_c = '1;
            end
            field_combo.fifo_port[i0].tail.data.next = next_c;
            field_combo.fifo_port[i0].tail.data.load_next = load_next_c;
        end

        always_ff @(posedge clk) begin
            if(field_combo.fifo_port[i0].tail.data.load_next) begin
                field_storage.fifo_port[i0].tail.data.value <= field_combo.fifo_port[i0].tail.data.next;
            end
        end
        assign hwif_out.fifo_port[i0].tail.data.value = field_storage.fifo_port[i0].tail.data.value;
        // Field: some_register_map.fifo_port[].status.full
        always_comb begin
            automatic logic [0:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.fifo_port[i0].status.full.value;
            load_next_c = '0;
            if(decoded_reg_strb.fifo_port[i0].status && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.fifo_port[i0].status.full.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
                load_next_c = '1;
            end else begin // HW Write
                next_c = hwif_in.fifo_port[i0].status.full.next;
                load_next_c = '1;
            end
            field_combo.fifo_port[i0].status.full.next = next_c;
            field_combo.fifo_port[i0].status.full.load_next = load_next_c;
        end
        always_ff @(posedge clk) begin
            if(generic_reset) begin
                field_storage.fifo_port[i0].status.full.value <= 1'h0;
            end else if(field_combo.fifo_port[i0].status.full.load_next) begin
                field_storage.fifo_port[i0].status.full.value <= field_combo.fifo_port[i0].status.full.next;
            end
        end
        assign hwif_out.fifo_port[i0].status.full.value = field_storage.fifo_port[i0].status.full.value;
        // Field: some_register_map.fifo_port[].status.empty
        always_comb begin
            automatic logic [0:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.fifo_port[i0].status.empty.value;
            load_next_c = '0;
            if(decoded_reg_strb.fifo_port[i0].status && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.fifo_port[i0].status.empty.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
                load_next_c = '1;
            end else begin // HW Write
                next_c = hwif_in.fifo_port[i0].status.empty.next;
                load_next_c = '1;
            end
            field_combo.fifo_port[i0].status.empty.next = next_c;
            field_combo.fifo_port[i0].status.empty.load_next = load_next_c;
        end
        always_ff @(posedge clk) begin
            if(rst) begin
                field_storage.fifo_port[i0].status.empty.value <= 1'h1;
            end else if(field_combo.fifo_port[i0].status.empty.load_next) begin
                field_storage.fifo_port[i0].status.empty.value <= field_combo.fifo_port[i0].status.empty.next;
            end
        end
        assign hwif_out.fifo_port[i0].status.empty.value = field_storage.fifo_port[i0].status.empty.value;
        // Field: some_register_map.fifo_port[].status.almost_empty
        always_comb begin
            automatic logic [0:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.fifo_port[i0].status.almost_empty.value;
            load_next_c = '0;
            if(decoded_reg_strb.fifo_port[i0].status && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.fifo_port[i0].status.almost_empty.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
                load_next_c = '1;
            end else begin // HW Write
                next_c = hwif_in.fifo_port[i0].status.almost_empty.next;
                load_next_c = '1;
            end
            field_combo.fifo_port[i0].status.almost_empty.next = next_c;
            field_combo.fifo_port[i0].status.almost_empty.load_next = load_next_c;
        end
        always_ff @(posedge clk) begin
            if(rst) begin
                field_storage.fifo_port[i0].status.almost_empty.value <= 1'h1;
            end else if(field_combo.fifo_port[i0].status.almost_empty.load_next) begin
                field_storage.fifo_port[i0].status.almost_empty.value <= field_combo.fifo_port[i0].status.almost_empty.next;
            end
        end
        assign hwif_out.fifo_port[i0].status.almost_empty.value = field_storage.fifo_port[i0].status.almost_empty.value;
        // Field: some_register_map.fifo_port[].status.almost_full
        always_comb begin
            automatic logic [0:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.fifo_port[i0].status.almost_full.value;
            load_next_c = '0;
            if(decoded_reg_strb.fifo_port[i0].status && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.fifo_port[i0].status.almost_full.value & ~decoded_wr_biten[5:5]) | (decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
                load_next_c = '1;
            end else begin // HW Write
                next_c = hwif_in.fifo_port[i0].status.almost_full.next;
                load_next_c = '1;
            end
            field_combo.fifo_port[i0].status.almost_full.next = next_c;
            field_combo.fifo_port[i0].status.almost_full.load_next = load_next_c;
        end
        always_ff @(posedge clk) begin
            if(rst) begin
                field_storage.fifo_port[i0].status.almost_full.value <= 1'h0;
            end else if(field_combo.fifo_port[i0].status.almost_full.load_next) begin
                field_storage.fifo_port[i0].status.almost_full.value <= field_combo.fifo_port[i0].status.almost_full.next;
            end
        end
        assign hwif_out.fifo_port[i0].status.almost_full.value = field_storage.fifo_port[i0].status.almost_full.value;
    end
    assign hwif_out.empty_addrmap.req = decoded_reg_strb.empty_addrmap;
    assign hwif_out.empty_addrmap.addr = decoded_addr[2:0];
    assign hwif_out.empty_addrmap.req_is_wr = decoded_req_is_wr;
    assign hwif_out.empty_addrmap.wr_data = decoded_wr_data;
    assign hwif_out.empty_addrmap.wr_biten = decoded_wr_biten;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    always_comb begin
        automatic logic wr_ack;
        wr_ack = '0;
        wr_ack |= hwif_in.empty_addrmap.wr_ack;
        external_wr_ack = wr_ack;
    end
    assign cpuif_wr_ack = external_wr_ack | (decoded_req & decoded_req_is_wr & ~decoded_strb_is_external);
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------
    logic readback_external_rd_ack_c;
    always_comb begin
        automatic logic rd_ack;
        rd_ack = '0;
        rd_ack |= hwif_in.chip_id_reg.rd_ack;
        rd_ack |= hwif_in.empty_addrmap.rd_ack;
        readback_external_rd_ack_c = rd_ack;
    end

    logic readback_external_rd_ack;

    assign readback_external_rd_ack = readback_external_rd_ack_c;

    logic readback_err;
    logic readback_done;
    logic [31:0] readback_data;

    // Assign readback values to a flattened array
    logic [31:0] readback_array[30];
    assign readback_array[0] = hwif_in.chip_id_reg.rd_ack ? hwif_in.chip_id_reg.rd_data : '0;
    assign readback_array[1][3:0] = (decoded_reg_strb.link_status && !decoded_req_is_wr) ? field_storage.link_status.port0.value : '0;
    assign readback_array[1][7:4] = (decoded_reg_strb.link_status && !decoded_req_is_wr) ? field_storage.link_status.port1.value : '0;
    assign readback_array[1][11:8] = (decoded_reg_strb.link_status && !decoded_req_is_wr) ? field_storage.link_status.port2.value : '0;
    assign readback_array[1][15:12] = (decoded_reg_strb.link_status && !decoded_req_is_wr) ? field_storage.link_status.port3.value : '0;
    assign readback_array[1][31:16] = '0;
    assign readback_array[2][1:0] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data0.value : '0;
    assign readback_array[2][3:2] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data1.value : '0;
    assign readback_array[2][5:4] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data2.value : '0;
    assign readback_array[2][7:6] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data3.value : '0;
    assign readback_array[2][9:8] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data4.value : '0;
    assign readback_array[2][11:10] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data5.value : '0;
    assign readback_array[2][13:12] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data6.value : '0;
    assign readback_array[2][15:14] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data7.value : '0;
    assign readback_array[2][17:16] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data8.value : '0;
    assign readback_array[2][19:18] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data9.value : '0;
    assign readback_array[2][21:20] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data10.value : '0;
    assign readback_array[2][23:22] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data11.value : '0;
    assign readback_array[2][25:24] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data12.value : '0;
    assign readback_array[2][27:26] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data13.value : '0;
    assign readback_array[2][29:28] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data14.value : '0;
    assign readback_array[2][31:30] = (decoded_reg_strb.myRegInst && !decoded_req_is_wr) ? field_storage.myRegInst.data15.value : '0;
    assign readback_array[3][15:0] = (decoded_reg_strb.spi4_pkt_count && !decoded_req_is_wr) ? field_storage.spi4_pkt_count.port1.value : '0;
    assign readback_array[3][31:16] = (decoded_reg_strb.spi4_pkt_count && !decoded_req_is_wr) ? field_storage.spi4_pkt_count.port0.value : '0;
    assign readback_array[4][7:0] = (decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) ? field_storage.gige_pkt_count_reg.port3.value : '0;
    assign readback_array[4][15:8] = (decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) ? field_storage.gige_pkt_count_reg.port2.value : '0;
    assign readback_array[4][23:16] = (decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) ? field_storage.gige_pkt_count_reg.port1.value : '0;
    assign readback_array[4][31:24] = (decoded_reg_strb.gige_pkt_count_reg && !decoded_req_is_wr) ? field_storage.gige_pkt_count_reg.port0.value : '0;
    for(genvar i0=0; i0<8; i0++) begin
        assign readback_array[i0*3 + 5][31:0] = (decoded_reg_strb.fifo_port[i0].head && !decoded_req_is_wr) ? field_storage.fifo_port[i0].head.data.value : '0;
        assign readback_array[i0*3 + 6][31:0] = (decoded_reg_strb.fifo_port[i0].tail && !decoded_req_is_wr) ? field_storage.fifo_port[i0].tail.data.value : '0;
        assign readback_array[i0*3 + 7][0:0] = (decoded_reg_strb.fifo_port[i0].status && !decoded_req_is_wr) ? field_storage.fifo_port[i0].status.full.value : '0;
        assign readback_array[i0*3 + 7][1:1] = (decoded_reg_strb.fifo_port[i0].status && !decoded_req_is_wr) ? field_storage.fifo_port[i0].status.empty.value : '0;
        assign readback_array[i0*3 + 7][3:2] = '0;
        assign readback_array[i0*3 + 7][4:4] = (decoded_reg_strb.fifo_port[i0].status && !decoded_req_is_wr) ? field_storage.fifo_port[i0].status.almost_empty.value : '0;
        assign readback_array[i0*3 + 7][5:5] = (decoded_reg_strb.fifo_port[i0].status && !decoded_req_is_wr) ? field_storage.fifo_port[i0].status.almost_full.value : '0;
        assign readback_array[i0*3 + 7][31:6] = '0;
    end
    assign readback_array[29] = hwif_in.empty_addrmap.rd_ack ? hwif_in.empty_addrmap.rd_data : '0;

    // Reduce the array
    always_comb begin
        automatic logic [31:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr & ~decoded_strb_is_external;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<30; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign external_rd_ack = readback_external_rd_ack;
    assign cpuif_rd_ack = readback_done | readback_external_rd_ack;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
